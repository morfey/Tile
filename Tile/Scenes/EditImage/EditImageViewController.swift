//
//  EditImageViewController.swift
//  Tile
//
//  Created by  Tim on 16.10.2017.
//  Copyright (c) 2017 TimHazhyi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import AKImageCropperView
import Photos
import iOSPhotoEditor

protocol EditImageDisplayLogic: class
{
    func displayFiltersScrollView(viewModel: UIScrollView)
    func displayTileWithImage(viewModel: EditImage.ImageForTile.ViewModel)
    func filterButtonTapped(sender: UIButton)
    func setImage(image: UIImage)
}

class EditImageViewController: UIViewController, EditImageDisplayLogic, UIImagePickerControllerDelegate, UINavigationControllerDelegate, UICollectionViewDelegate, UICollectionViewDataSource, UITextViewDelegate
{
    var interactor: EditImageBusinessLogic?
    var router: (NSObjectProtocol & EditImageRoutingLogic & EditImageDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    @IBOutlet weak var conteinerImage: UIView!
    @IBOutlet weak var originalImage: UIImageView!
    @IBOutlet weak var filtersScrollView: UIScrollView!
    @IBOutlet weak var activityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var imageCropperView: AKImageCropperView!
    @IBOutlet weak var actionView: UIView!
    @IBOutlet weak var instrumentsView: UIView!
    @IBOutlet weak var imagesCollectionView: UICollectionView!
    @IBOutlet weak var effectsView: UIView!
    
    private func setup()
    {
        let viewController = self
        let interactor = EditImageInteractor()
        let presenter = EditImagePresenter()
        let router = EditImageRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: View lifecycle
    var imagePicker: UIImagePickerController!
    var angle: Double = 0.0
    var imgSelected = false
    var images: NSMutableArray!
    var totalImageCountNeeded: Int!
    var tile: Tile!
    var lastTextViewTransform: CGAffineTransform?
    var lastTextViewTransCenter: CGPoint?
    var lastTextViewFont:UIFont?
    var activeTextView: UITextView?
    var imageViewToPan: UIImageView?
    var lastPanPoint: CGPoint?
    
    var CIFilterNames = [
        "CIPhotoEffectChrome",
        "CIPhotoEffectFade",
        "CIPhotoEffectInstant",
        "CIPhotoEffectNoir",
        "CIPhotoEffectProcess",
        "CIPhotoEffectTonal",
        "CIPhotoEffectTransfer",
        "CISepiaTone"
    ]
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        imagesCollectionView.delegate = self
        imagesCollectionView.dataSource = self
        imagePicker = UIImagePickerController()
        imagePicker.allowsEditing = true
        imagePicker.delegate = self
        tile = router?.dataStore?.tile
        title = tile.name
        let img = tile.imageUrl
        originalImage.kf.setImage(with: img, placeholder: #imageLiteral(resourceName: "FullImage"), options: nil, progressBlock: nil) { (nil, error, cache, s) in
            self.configure()
            self.effectsView.isHidden = true
        }
        fetchPhotos()
    }
    
    @objc func filterButtonTapped(sender: UIButton) {
        originalImage.isHidden = true
        let button = sender as UIButton
        imageCropperView.image = button.backgroundImage(for: .normal)
    }
    
    @IBAction func saveBtnTapped(_ sender: Any) {
        imageCropperView.endEditing(true)
        if let image = imageCropperView.image != nil ? imageCropperView.toImage() : originalImage.image {
            let request = EditImage.ImageForTile.Request(image: image)
            interactor?.saveImageForTile(request: request)
        }
    }
    
    @IBAction func doneBtnTapped(_ sender: Any) {
        imageCropperView.endEditing(true)
    }
    
    @IBAction func addTextBtnTapped(_ sender: Any) {
        let textView = UITextView(frame: CGRect(x: 0, y: imageCropperView.center.y,
                                                width: UIScreen.main.bounds.width, height: 60))
        
        //Text Attributes
        textView.textAlignment = .center
        textView.font = UIFont(name: "Helvetica", size: 30)
        textView.textColor = .cyan
        textView.layer.shadowColor = UIColor.black.cgColor
        textView.layer.shadowOffset = CGSize(width: 1.0, height: 0.0)
        textView.layer.shadowOpacity = 0.2
        textView.layer.shadowRadius = 1.0
        textView.layer.backgroundColor = UIColor.clear.cgColor
        //
        textView.autocorrectionType = .no
        textView.isScrollEnabled = false
        textView.delegate = self
        self.imageCropperView.addSubview(textView)
        addGestures(view: textView)
        textView.becomeFirstResponder()
    }
    
    @IBAction func cropBtnTapped(_ sender: Any) {
        originalImage.isHidden = true
        if imageCropperView.isOverlayViewActive {
            imageCropperView.image = imageCropperView.croppedImage
            imageCropperView.hideOverlayView(animationDuration: 0.3)
            UIView.animate(withDuration: 0.3, delay: 0, options: UIViewAnimationOptions.curveLinear, animations: {
                self.actionView.alpha = 0
            }, completion: nil)
        } else {
            imageCropperView.isHidden = false
            actionView.isHidden = false
            let image = imageCropperView.image != nil ? imageCropperView.image : originalImage.image
            imageCropperView.image = image
            imageCropperView.showOverlayView(animationDuration: 0.3)
            UIView.animate(withDuration: 0.3, delay: 0.3, options: UIViewAnimationOptions.curveLinear, animations: {
                self.actionView.alpha = 1
            }, completion: nil)
        }
    }
    
    @IBAction func rotateAction(_ sender: AnyObject) {
        angle += .pi / 2
        imageCropperView.rotate(angle, withDuration: 0.3, completion: { _ in
            if self.angle == 2 * .pi {
                self.angle = 0.0
            }
        })
    }
    
    @IBAction func resetAction(_ sender: AnyObject) {
        imageCropperView.reset(animationDuration: 0.3)
        angle = 0.0
    }
    
    @IBAction func closeTapped(_ sender: Any) {
        dismiss(animated: true, completion: nil)
    }
    
    @IBAction func editImageBtnTapped(_ sender: Any) {
        let photoEditor = PhotoEditorViewController(nibName:"PhotoEditorViewController",bundle: Bundle(for: PhotoEditorViewController.self))
        
        photoEditor.photoEditorDelegate = self
        photoEditor.hiddenControls = [.share, .save]
        photoEditor.image = imageCropperView.image
        
        present(photoEditor, animated: true, completion: nil)
    }
    
    
    func configure() {
        imageCropperView.image = originalImage.image!
        let request = EditImage.Filters.Request(filters: CIFilterNames, originalImage: originalImage.image!)
        interactor?.applyFilters(request: request)
    }
    
    func cameraPicker() {
        if UIImagePickerController.isSourceTypeAvailable(.camera) {
            imagePicker.sourceType = UIImagePickerControllerSourceType.camera
            imagePicker.allowsEditing = false
            self.present(imagePicker, animated: true, completion: nil)
        }
    }
    
    func setImage(image: UIImage) {
        originalImage.image = image
    }
    
    func displayFiltersScrollView(viewModel: UIScrollView) {
        activityIndicator.stopAnimating()
        viewModel.subviews.forEach {
            filtersScrollView.addSubview($0)
        }
        filtersScrollView.contentSize = viewModel.contentSize
    }
    
    func fetchPhotos () {
        images = NSMutableArray()
        totalImageCountNeeded = 5
        fetchPhotoAtIndexFromEnd(index: 0)
    }
    
    func fetchPhotoAtIndexFromEnd(index:Int) {
        
        let imgManager = PHImageManager.default()
        let requestOptions = PHImageRequestOptions()
        requestOptions.isSynchronous = true
        
        let fetchOptions = PHFetchOptions()
        fetchOptions.sortDescriptors = [NSSortDescriptor(key:"creationDate", ascending: true)]
        
        let fetchResult: PHFetchResult = PHAsset.fetchAssets(with: PHAssetMediaType.image, options: fetchOptions)
        
        if fetchResult.count > 0 {
            imgManager.requestImage(for: fetchResult.object(at: fetchResult.count - 1 - index) as PHAsset, targetSize: view.frame.size, contentMode: PHImageContentMode.aspectFill, options: requestOptions, resultHandler: { (image, _) in
                self.images.add(image!)
                if index + 1 < fetchResult.count && self.images.count < self.totalImageCountNeeded {
                    self.fetchPhotoAtIndexFromEnd(index: index + 1)
                } else {
                    print("Completed array: \(self.images)")
                }
            })
        }
    }
    
    func displayTileWithImage(viewModel: EditImage.ImageForTile.ViewModel) {
        router?.routeToTiles(segue: nil)
    }
    
    // MARK: UIImagePicker
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
        if let image = info[UIImagePickerControllerEditedImage] as? UIImage {
            originalImage.image = image
            configure()
            imgSelected = true
            effectsView.isHidden = true
        } else if let image = info[UIImagePickerControllerOriginalImage] as? UIImage {
            originalImage.image = image
            configure()
            imgSelected = true
            effectsView.isHidden = true
        }
        imagePicker.dismiss(animated: true, completion: nil)
    }
    
    // MARK: UICollectionViewDelegate & DataSource
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return images.count + 1
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if let cell = imagesCollectionView.dequeueReusableCell(withReuseIdentifier: "imageCell", for: indexPath) as? ImageCell {
            if indexPath.row == 0 {
                cell.configureCell(image: nil, first: true)
            } else if indexPath.row == images.count {
                let image = UIImage(named: "FullImage.png")
                cell.configureCell(image: image, first: false)
            } else {
                cell.configureCell(image: images.object(at: indexPath.row) as? UIImage, first: false)
            }
            return cell
        } else {
            return UICollectionViewCell()
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if let cell = collectionView.cellForItem(at: indexPath) as? ImageCell {
            if indexPath.row == 0 {
                cameraPicker()
            } else if indexPath.row == images.count {
                imagePicker.sourceType = .photoLibrary
                present(imagePicker, animated: true, completion: nil)
            } else {
                originalImage.image = cell.imageView.image!
                configure()
                imgSelected = true
                effectsView.isHidden = true
            }
        }
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: UITextViewDelegate
    
    func textViewDidChange(_ textView: UITextView) {
        let rotation = atan2(textView.transform.b, textView.transform.a)
        if rotation == 0 {
            let oldFrame = textView.frame
            let sizeToFit = textView.sizeThatFits(CGSize(width: oldFrame.width, height:CGFloat.greatestFiniteMagnitude))
            textView.frame.size = CGSize(width: oldFrame.width, height: sizeToFit.height)
        }
    }
    
    func textViewDidBeginEditing(_ textView: UITextView) {
//        isTyping = true
        lastTextViewTransform =  textView.transform
        lastTextViewTransCenter = textView.center
        lastTextViewFont = textView.font!
        activeTextView = textView
        textView.superview?.bringSubview(toFront: textView)
        textView.font = UIFont(name: "Helvetica", size: 30)
        UIView.animate(withDuration: 0.3,
                       animations: {
                        textView.transform = CGAffineTransform.identity
                        textView.center = CGPoint(x: UIScreen.main.bounds.width / 2,
                                                  y:  UIScreen.main.bounds.height / 5)
        }, completion: nil)
        
    }
    
    func textViewDidEndEditing(_ textView: UITextView) {
        guard lastTextViewTransform != nil && lastTextViewTransCenter != nil && lastTextViewFont != nil
            else {
                return
        }
        activeTextView = nil
        textView.font = self.lastTextViewFont!
        UIView.animate(withDuration: 0.3,
                       animations: {
                        textView.transform = self.lastTextViewTransform!
                        textView.center = self.lastTextViewTransCenter!
        }, completion: nil)
    }
}

extension EditImageViewController: PhotoEditorDelegate {
    
    func doneEditing(image: UIImage) {
        imageCropperView.image = image
    }
    
    func canceledEditing() {
        print("Canceled")
    }
}

extension UIView {
    func toImage() -> UIImage {
        UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.isOpaque, 0.0)
        self.drawHierarchy(in: self.bounds, afterScreenUpdates: false)
        let snapshotImageFromMyView = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return snapshotImageFromMyView!
    }
}

extension UIImageView {
    
    func alphaAtPoint(_ point: CGPoint) -> CGFloat {
        
        var pixel: [UInt8] = [0, 0, 0, 0]
        let colorSpace = CGColorSpaceCreateDeviceRGB();
        let alphaInfo = CGImageAlphaInfo.premultipliedLast.rawValue
        
        guard let context = CGContext(data: &pixel, width: 1, height: 1, bitsPerComponent: 8, bytesPerRow: 4, space: colorSpace, bitmapInfo: alphaInfo) else {
            return 0
        }
        
        context.translateBy(x: -point.x, y: -point.y);
        
        layer.render(in: context)
        
        let floatAlpha = CGFloat(pixel[3])
        
        return floatAlpha
    }
}
